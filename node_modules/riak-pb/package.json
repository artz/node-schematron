{
  "name": "riak-pb",
  "version": "0.1.8",
  "description": "Riak Protocol Buffers Client",
  "main": "balancing_client.js",
  "scripts": {
    "test": "tap tests/client.js "
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/CrowdProcess/riak-pb.git"
  },
  "dependencies": {
    "protobuf.js": ">=0.0.17",
    "butils": "*"
  },
  "devDependencies": {
    "tap": "*",
    "async": "*"
  },
  "keywords": [
    "riak",
    "protocol",
    "buffers",
    "database",
    "client"
  ],
  "author": {
    "name": "CrowdProcess"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "021247b24fdf0982ff4bb6c08c44a959585427e6",
  "readme": "# riak-pb\n\nRiak Protocol Buffer Client for Node.js.\n\nFeatures:\n\n* streaming\n* fail-over\n* automatic retry\n* connection pooling\n* load balancing\n\n## Install\n\nInclude `riak-pb` in your dependency list or install:\n\n```bash\n$ npm install riak-pb\n```\n\n## Use\n\n### Require\n\n```javascript\nvar riak = require('riak-pb');\n```\n\n### Create Client\n\n```javascript\nvar client = riak();\n```\n\nOr, with options:\n\n```javascript\nvar options = {\n  nodes: [\n    {\n      host: 'myriakhostname.acme.com',\n      port: 8087 }],\n  maxPool: 5,     // Maximum number of connections in the connection pool - default is 5\n  maxRetries: 10, // maximum times the client tries to reconnect before failing - default is 10\n  maxDelay: 2000, // maximum time (ms) between reconnections - reconnections have an exponential backoff, but limited to this value - default is 2000\n};\n\nvar client = riak(options);\n```\n\n### Access Riak\n\nThe API is based on [the Riak Protocol spec](http://docs.basho.com/riak/1.3.1/references/apis/protocol-buffers/), check it out to find out about what arguments you need.\n\n\n#### put(params, callback)\n\nExamples:\n\n```javascript\nclient.put({\n    bucket: 'test',\n    key: 'test',\n    content: { \n      value: '{\"test\":\"data\"}',\n      content_type: 'application/json',\n      indexes: [{ key: 'test_bin', value: 'test' }] \n    } \n  },\n  function (err, reply) {\n    //...\n    console.warn(\"ERr: \"+JSON.stringify(err)+\" Reply: \"+JSON.stringify(reply));\n  });\n```\n\nWith multiple indexes:\n\n```javascript\n  var indexes = [{ key: 'key1_bin', value: 'value1' }, { key: 'key2_bin', value: 'value2' }];\n  var options = { bucket: 'test', key: 'test-put-index', content: { value: '{\"test\":\"data\"}', content_type: 'application/json', indexes: indexes }, return_body: true };\n\n  client.put(options, function(err, reply) {\n    //...\n  });\n```\n\nWith vector clock:\n\n```javascript\nvar options = { bucket: 'test', key: 'test-vclock', content: { value: '{\"test\":\"data\"}', content_type: 'application/json' }, return_body: true };\nclient.put(options, function (err, reply) {\n  if (err) throw err;\n  var options = { bucket: 'test', key: 'test-vclock', content: { value: '{\"test\":\"data\"}', content_type: 'application/json' }, return_body: true };\n  options.vclock = reply.vclock;\n  client.put(options, function(reply) {\n    // ...\n  });\n});\n```\n\n#### get(params, callback)\n\nExample:\n\n```javascript\nclient.get({ bucket: 'test', key: 'test' }, function (err, reply) {\n  t.equal(++cbCount, 1);\n  t.notOk(err, err && err.message);\n  t.ok(Array.isArray(reply.content));\n  t.equal(reply.content.length, 1);\n  t.equal(reply.content[0].value, '{\"test\":\"data\"}');\n  t.end();\n});\n```\n\n#### getIndex(params, callback)\n\nExample:\n\n```javascript\nclient.getIndex({\n  bucket: 'test',\n  index: 'test_bin',\n  qtype: 0,\n  key: 'test' },\n  function (err, reply) {\n    //...\n  });\n```\n\nRange query example:\n\n```javascript\nclient.getIndex({\n  bucket: 'test',\n  index: 'test_bin',\n  qtype: 1,\n  range_min: 'abc',\n  range_max: 'abcdef' },\n  function (err, reply) {\n    //...\n  });\n```\n\n#### setBucket(params, callback)\n\nExample:\n\n```javascript\nclient.setBucket('test', { allow_mult: true, n_val: 3 },\n  function (err, reply) {\n    /// ...\n  });\n```\n\n#### getKeys(bucket[, callback])\n\nWith callback:\n\n```javascript\nclient.getKeys('test', function (err, keys) {\n  /// ...\n});\n```\n\nStreaming:\n\n```javascript\nvar s = client.getKeys('test');\n\ns.on('readable', function() {\n  var key;\n  while(key = s.read()) {\n    console.log('got key:', key);\n  }\n});\n```\n\n#### search(params[, callback])\n\nWith callback:\n\n```javascript\nclient.search({ index: 'key1_bin', q: 'test' }, function (err, reply) {\n  /// ...\n});\n```\n\n#### mapred(params[, callback])\n\nWith callback:\n\n```javascript\nvar request = {\n  inputs: 'test',\n  query: [\n    {\n      map: {\n        source: 'function (v) { return [[v.bucket, v.key]]; }',\n        language: 'javascript',\n        keep: true\n      }\n    }]};\n\nvar params = { request: JSON.stringify(request), content_type: 'application/json' };\n\nclient.mapred(params, function (err, responses) {\n  /// ...\n});\n```\n\nStreaming:\n\n```javascript\nvar request = {\n  inputs: 'test',\n  query: [\n    {\n      map: {\n        source: 'function (v) { return [[v.bucket, v.key]]; }',\n        language: 'javascript',\n        keep: true\n      }\n    }]};\n\nvar params = { request: JSON.stringify(request), content_type: 'application/json' };\n\nvar s = client.mapred(params);\n\ns.on('readable', function() {\n  var res;\n  while(res = s.read()) {\n    console.log('got res:', res);\n  }\n});\n```\n\n### del(bucket, id[, callback])\n### del(bucket, options[, callback])\n\n```javascript\nclient.del('test', key, function(err) {\n  // ...\n});\n```\n\nor, with options:\n\n```javascript\nclient.del('test', {key: key, vclock: vclock}, function(err) {\n  // ...\n});\n```\n\n### Disconnect\n\nQueues a disconnect after all the pending requests are complete\n\n```javascript\nclient.disconnect();\n```\n\n#### Others\n\n* getBuckets(callback) // callback(err, buckets)\n* getBucket(bucket[, callback]) // callback(err, bucketInfo)\n* setBucket(bucket, props[, callback]) // callback(err)\n* setClientId (client_id[, callback]) // callback(err)\n* getClientId (callback) // callback(err, clientId)\n* ping (callback) // callback(err)\n* getServerInfo(callback) // callback(err, reply)\n\n#### Events\n\nThe client object emits these events:\n\n* 'error' - (err)\n* 'warning' - (warning) - Emitted when there is an internal error, like a disconnection. In this case, the client will transparently attempt to reconnect (up to a limit of attempts) and a \"warning\" will be emitted with the underlying error object.\n",
  "bugs": {
    "url": "https://github.com/CrowdProcess/riak-pb/issues"
  },
  "homepage": "https://github.com/CrowdProcess/riak-pb",
  "_id": "riak-pb@0.1.8",
  "dist": {
    "shasum": "1e9cdac4a83e62c741a48ac37b49ccad2ae9968a"
  },
  "_from": "riak-pb@",
  "_resolved": "https://registry.npmjs.org/riak-pb/-/riak-pb-0.1.8.tgz"
}
